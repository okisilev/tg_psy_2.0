const crypto = require('crypto');

class ProdamusService {
    constructor() {
        this.shopId = process.env.PRODAMUS_SHOP_ID;
        this.secretKey = process.env.PRODAMUS_SECRET_KEY;
        // URL вашей платежной страницы в Продамус
        this.paymentFormUrl = process.env.PRODAMUS_PAYMENT_FORM_URL;
        
        if (!this.paymentFormUrl) {
            throw new Error('PRODAMUS_PAYMENT_FORM_URL не настроен. Укажите URL вашей платежной страницы в .env файле');
        }
    }

    /**
     * Создает платежную ссылку в системе Продамус
     * @param {Object} paymentData - Данные платежа
     * @returns {Promise<Object>} - Результат создания платежа
     */
    async createPayment(paymentData) {
        try {
            const { userId, amount, description, orderId } = paymentData;
            
            // Формируем данные для платежной ссылки согласно документации Продамус
            const data = {
                do: 'pay',
                sys: this.shopId,
                order_id: orderId,
                amount: amount,
                currency: process.env.CURRENCY || 'RUB',
                description: description,
                client_email: `${userId}@telegram.user`,
                success_url: `${process.env.WEBHOOK_URL}/success`,
                failure_url: `${process.env.WEBHOOK_URL}/failure`,
                webhook_url: process.env.PRODAMUS_WEBHOOK_URL,
                // Дополнительные поля для Telegram пользователя
                custom_fields: JSON.stringify({
                    telegram_user_id: userId
                })
            };

            // Создаем HMAC подпись
            const signature = this.createHmacSignature(data);
            data.signature = signature;

            // Формируем URL с параметрами
            const paymentUrl = this.buildPaymentUrl(data);

            return {
                success: true,
                paymentUrl: paymentUrl,
                orderId: orderId
            };
        } catch (error) {
            console.error('Prodamus payment creation error:', error.message);
            return {
                success: false,
                error: 'Payment creation failed: ' + error.message
            };
        }
    }

    /**
     * Создает HMAC подпись для данных платежа
     * @param {Object} data - Данные для подписи
     * @returns {string} - HMAC подпись
     */
    createHmacSignature(data) {
        // Сортируем ключи для правильного формирования подписи
        const sortedKeys = Object.keys(data).sort();
        const signatureString = sortedKeys
            .map(key => `${key}=${data[key]}`)
            .join('&');
            
        return crypto
            .createHmac('sha256', this.secretKey)
            .update(signatureString, 'utf8')
            .digest('hex');
    }

    /**
     * Формирует URL для платежной формы
     * @param {Object} data - Данные платежа
     * @returns {string} - URL платежной формы
     */
    buildPaymentUrl(data) {
        const params = new URLSearchParams();
        
        Object.keys(data).forEach(key => {
            if (data[key] !== null && data[key] !== undefined) {
                params.append(key, data[key]);
            }
        });

        return `${this.paymentFormUrl}?${params.toString()}`;
    }

    /**
     * Проверяет HMAC подпись webhook от Продамус
     * @param {Object} webhookData - Данные webhook
     * @param {string} signature - Подпись из заголовка
     * @returns {boolean} - Результат проверки
     */
    verifyWebhookSignature(webhookData, signature) {
        try {
            // Создаем подпись на основе данных webhook
            const sortedKeys = Object.keys(webhookData).sort();
            const signatureString = sortedKeys
                .map(key => `${key}=${webhookData[key]}`)
                .join('&');
                
            const expectedSignature = crypto
                .createHmac('sha256', this.secretKey)
                .update(signatureString, 'utf8')
                .digest('hex');

            // Безопасное сравнение подписей
            return crypto.timingSafeEqual(
                Buffer.from(signature, 'hex'),
                Buffer.from(expectedSignature, 'hex')
            );
        } catch (error) {
            console.error('HMAC verification error:', error);
            return false;
        }
    }
}

module.exports = ProdamusService;